
package main

import (
	"fmt"
	"bytes"
	"strconv"
	"strings"
)

var (
	strand = ("ACCATGAGATGTGGAGATGTGGGGTAGTCAGATGTGGTCCCGATGTGGGATGTGGGATGTGGGATGTGGACGATGTGGGAGATGTGGGAGATGTGGGGAATTCAGATGTGGTGGGTTTAAGTCGCGATGTGGGATGTGGGGATGTGGGGCTGATGTGGGATGTGGTCTCGATGTGGCGCGATGTGGTTAGATGTGGGATGTGGTACTGTGATGTGGAATTTCTGATGTGGCGATGTGGGATGTGGCCGATGTGGCATGATGTGGTGATGTGGGATGTGGCGATGTGGTGATGTGGGATGTGGGATGTGGTGCCTACGGCGGATGTGGGGAGTCAGATGTGGCGTAATTGATGTGGGCAGATCTCCTAGGATGTGGCGTATGGGTGATGTGGTTGGATGTGGTAAGCGCGTGTGAACCTTTGCCGATGTGGGATGTGGGGATGTGGGATGTGGGATGTGGTCTCGATGTGGGATGTGGAGATGTGGTGAAAGATGTGGGGATGTGGTGATGTGGGATGTGGTGATGTGGTACTTGATGTGGTCCAGATGTGGTCGATGTGGGGAGATGTGGTGATGTGGAGTTGATGTGGCTAGATGTGGGCTACGGATGTGGGGTTCGGTGAGGATGTGGTGGAGCCGATGTGGGTTAGATGTGGCCGATGTGGGATGTGGGATGTGGTGATGTGGTCGATGTGGCATACTTATGGTTGATGTGGGATGTGGGATGTGGGATGTGGCGATGTGGTGATGTGGAGCCGCGATGTGGGATGTGGGTTGATGTGGCCCCTCGTTTAGCCATGATGTGGAGGATGTGGCTACTTTTCGATGTGGCAGATGTGGGATGTGGGATGTGG")
	motif  = ("GATGTGGGA")
	matches bytes.Buffer
)

func findNextIndex (dna string, strnd_posn int) {

	if i := 0; strings.Contains(dna, motif) == true {

		i = strings.Index(dna, motif)	/*index of match*/

		strnd_posn = strnd_posn + i	/*start position of substring in original strand*/

		matches.WriteString(strconv.Itoa(strnd_posn))
		matches.WriteString(" ")

		strnd_posn++
		i++

		dna = dna[i:]

		findNextIndex(dna, strnd_posn)
	}
}

func main() {

	findNextIndex(strand, 1)	/*starts at base 1*/
	fmt.Println(matches.String())

}
